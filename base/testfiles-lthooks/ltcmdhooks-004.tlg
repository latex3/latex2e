This is a generated file for the l3build validation system.
Don't change this file in any respect.
Command patched with expand-and-redefine
-> Adding cmd hook to 'foo' (before):
[lthooks] analyzing '\foo'
[lthooks] \foo=macro:->\@protected@testopt \foo \\foo {opt}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/foo/before' on input line ...:
[lthooks] Add to hook 'cmd/foo/before' (top-level) on input line ...
[lthooks]    <- \typeout {[top-level] \string \foo \space with [##1]{##2}}
[lthooks] Update code for hook 'cmd/foo/before' on input line ...:
-> Adding cmd hook to 'foo' (after):
[lthooks] analyzing '\foo'
[lthooks] \foo=macro:->\@protected@testopt \foo \\foo {opt}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/foo/after' on input line ...:
[lthooks] Add to hook 'cmd/foo/after' (lbl) on input line ...
[lthooks]    <- \typeout {[main] \string \foo \space with [##1]{##2}}
[lthooks] Update code for hook 'cmd/foo/after' on input line ...:
Code labels for sorting:
 lbl
Data structure for label rules:
 lbl = 0 -> 
[lthooks] Handled code for lbl
[top-level] \foo with [##1]{##2}
\foo[hello]{world}
[main] \foo with [##1]{##2}
Command patched with retokenisation
-> Adding cmd hook to 'bar' (before):
[lthooks] analyzing '\bar'
[lthooks] \bar=macro:#1/#2/->\typeout {\string \bar {#1}{#2}}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Update code for hook 'cmd/bar/before' on input line ...:
[lthooks] Add to hook 'cmd/bar/before' (top-level) on input line ...
[lthooks]    <- \typeout {[top-level] \string \bar \space with {##1}{##2}}
[lthooks] Update code for hook 'cmd/bar/before' on input line ...:
-> Adding cmd hook to 'bar' (after):
[lthooks] analyzing '\bar'
[lthooks] \bar=macro:#1/#2/->\UseHookWithArguments {cmd/bar/before}{2}{#1}{#2}\typeout {\string \bar {#1}{#2}}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Update code for hook 'cmd/bar/after' on input line ...:
[lthooks] Add to hook 'cmd/bar/after' (lbl) on input line ...
[lthooks]    <- \typeout {[main] \string \bar \space with {##1}{##2}}
[lthooks] Update code for hook 'cmd/bar/after' on input line ...:
Code labels for sorting:
 lbl
Data structure for label rules:
 lbl = 0 -> 
[lthooks] Handled code for lbl
[top-level] \bar with {##1}{##2}
\bar{hello}{world}
[main] \bar with {##1}{##2}
ltcmd Command (always expand-and-redefine)
-> Adding cmd hook to 'baz' (before):
[lthooks] analyzing '\baz'
[lthooks] \baz=\protected macro:->\__cmd_start:nNNnnn {mo}\baz  \baz code {\__cmd_grab_m_1:w \__cmd_grab_D:w []}{}{}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/baz/before' on input line ...:
[lthooks] Add to hook 'cmd/baz/before' (top-level) on input line ...
[lthooks]    <- \typeout {[top-level] \string \baz \space with {##1}[##2]}
[lthooks] Update code for hook 'cmd/baz/before' on input line ...:
-> Adding cmd hook to 'baz' (after):
[lthooks] analyzing '\baz'
[lthooks] \baz=\protected macro:->\__cmd_start:nNNnnn {mo}\baz  \baz code {\__cmd_grab_m_1:w \__cmd_grab_D:w []}{}{}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/baz/after' on input line ...:
[lthooks] Add to hook 'cmd/baz/after' (lbl) on input line ...
[lthooks]    <- \typeout {[main] \string \baz \space with {##1}[##2]}
[lthooks] Update code for hook 'cmd/baz/after' on input line ...:
Code labels for sorting:
 lbl
Data structure for label rules:
 lbl = 0 -> 
[lthooks] Handled code for lbl
[top-level] \baz with {##1}[##2]
\baz{hello}[world]
[main] \baz with {##1}[##2]
ltcmd expandable Command (always expand-and-redefine)
-> Adding cmd hook to 'boo' (before):
[lthooks] analyzing '\boo'
[lthooks] \boo=macro:->\__cmd_start_expandable:nNNNNn {om}\boo  \boo  \boo code ?{\__cmd_expandable_grab_D:w \boo (arg 1) []\__cmd_expandable_grab_m:w }
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/boo/before' on input line ...:
[lthooks] Add to hook 'cmd/boo/before' (top-level) on input line ...
[lthooks]    <- [top-level] \string \boo \space with [##1]{##2}
[lthooks] Update code for hook 'cmd/boo/before' on input line ...:
-> Adding cmd hook to 'boo' (after):
[lthooks] analyzing '\boo'
[lthooks] \boo=macro:->\__cmd_start_expandable:nNNNNn {om}\boo  \boo  \boo code ?{\__cmd_expandable_grab_D:w \boo (arg 1) []\__cmd_expandable_grab_m:w }
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Update code for hook 'cmd/boo/after' on input line ...:
[lthooks] Add to hook 'cmd/boo/after' (lbl) on input line ...
[lthooks]    <- [main] \string \boo \space with [##1]{##2}
[lthooks] Update code for hook 'cmd/boo/after' on input line ...:
Code labels for sorting:
 lbl
Data structure for label rules:
 lbl = 0 -> 
[lthooks] Handled code for lbl
[top-level] \boo with [##1]{##2}
\boo[hello]{world}
[main] \boo with [##1]{##2}
