This is a generated file for the l3build validation system.
Don't change this file in any respect.
-> Adding cmd hook to 'fooA' (before):
[lthooks] analyzing '\fooA'
[lthooks] \fooA=\long macro:#1#2#3->(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
**** Add to hook cmd/fooA/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooA' (after):
[lthooks] analyzing '\fooA'
[lthooks] \fooA=\long macro:#1#2#3->\UseHook {cmd/fooA/before}(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
**** Add to hook cmd/fooA/after (lbl) on input line ... <- after
> \fooA=\long macro:
#1#2#3->\UseHook {cmd/fooA/before}(#1,#2,#3)\UseHook {cmd/fooA/after}.
<argument> \fooA 
l. ...\test\newcommand\fooA[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooB' (before):
[lthooks] analyzing '\fooB'
[lthooks] \fooB=macro:->\@protected@testopt \fooB \\fooB {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooB/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooB' (after):
[lthooks] analyzing '\fooB'
[lthooks] \fooB=macro:->\@protected@testopt \fooB \\fooB {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooB/after (lbl) on input line ... <- after
> \fooB=robust macro:
->\@protected@testopt \fooB \\fooB {x}.
> \\fooB=\long macro:
> default #1=x.
[#1]#2#3->\UseHook {cmd/fooB/before}(#1,#2,#3)\UseHook {cmd/fooB/after}.
<recently read> }
l. ...\test\newcommand\fooB[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooC' (before):
[lthooks] analyzing '\fooC'
[lthooks] \fooC=macro:->\protect \fooC  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooC/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooC' (after):
[lthooks] analyzing '\fooC'
[lthooks] \fooC=macro:->\protect \fooC  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooC/after (lbl) on input line ... <- after
> \fooC=robust macro:
->\protect \fooC  .
> \fooC =\long macro:
#1#2#3->\UseHook {cmd/fooC/before}(#1,#2,#3)\UseHook {cmd/fooC/after}.
<argument> \fooC  
l. ......t\DeclareRobustCommand\fooC[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooD' (before):
[lthooks] analyzing '\fooD'
[lthooks] \fooD=macro:->\protect \fooD  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooD/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooD' (after):
[lthooks] analyzing '\fooD'
[lthooks] \fooD=macro:->\protect \fooD  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooD/after (lbl) on input line ... <- after
> \fooD=robust macro:
->\protect \fooD  .
> \fooD =robust macro:
->\@protected@testopt \fooD  \\fooD  {x}.
> \\fooD =\long macro:
> default #1=x.
[#1]#2#3->\UseHook {cmd/fooD/before}(#1,#2,#3)\UseHook {cmd/fooD/after}.
<recently read> }
l. ......eclareRobustCommand\fooD[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooE' (before):
[lthooks] analyzing '\fooE'
[lthooks] \fooE=macro:#1#2#3->(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
**** Add to hook cmd/fooE/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooE' (after):
[lthooks] analyzing '\fooE'
[lthooks] \fooE=macro:#1#2#3->\UseHook {cmd/fooE/before}(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
**** Add to hook cmd/fooE/after (lbl) on input line ... <- after
> \fooE=macro:
#1#2#3->\UseHook {cmd/fooE/before}(#1,#2,#3)\UseHook {cmd/fooE/after}.
<argument> \fooE 
l. ...\test\newcommand*\fooE[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooF' (before):
[lthooks] analyzing '\fooF'
[lthooks] \fooF=macro:->\@protected@testopt \fooF \\fooF {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooF/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooF' (after):
[lthooks] analyzing '\fooF'
[lthooks] \fooF=macro:->\@protected@testopt \fooF \\fooF {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooF/after (lbl) on input line ... <- after
> \fooF=robust macro:
->\@protected@testopt \fooF \\fooF {x}.
> \\fooF=macro:
> default #1=x.
[#1]#2#3->\UseHook {cmd/fooF/before}(#1,#2,#3)\UseHook {cmd/fooF/after}.
<recently read> }
l. ...\test\newcommand*\fooF[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooG' (before):
[lthooks] analyzing '\fooG'
[lthooks] \fooG=macro:->\protect \fooG  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooG/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooG' (after):
[lthooks] analyzing '\fooG'
[lthooks] \fooG=macro:->\protect \fooG  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooG/after (lbl) on input line ... <- after
> \fooG=robust macro:
->\protect \fooG  .
> \fooG =macro:
#1#2#3->\UseHook {cmd/fooG/before}(#1,#2,#3)\UseHook {cmd/fooG/after}.
<argument> \fooG  
l. ......\DeclareRobustCommand*\fooG[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooH' (before):
[lthooks] analyzing '\fooH'
[lthooks] \fooH=macro:->\protect \fooH  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooH/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooH' (after):
[lthooks] analyzing '\fooH'
[lthooks] \fooH=macro:->\protect \fooH  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooH/after (lbl) on input line ... <- after
> \fooH=robust macro:
->\protect \fooH  .
> \fooH =robust macro:
->\@protected@testopt \fooH  \\fooH  {x}.
> \\fooH =macro:
> default #1=x.
[#1]#2#3->\UseHook {cmd/fooH/before}(#1,#2,#3)\UseHook {cmd/fooH/after}.
<recently read> }
l. ......clareRobustCommand*\fooH[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooI' (before):
[lthooks] analyzing '\fooI'
[lthooks] \fooI=macro:->(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooI/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooI' (after):
[lthooks] analyzing '\fooI'
[lthooks] \fooI=macro:->\UseHook {cmd/fooI/before}(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooI/after (lbl) on input line ... <- after
> \fooI=macro:
->\UseHook {cmd/fooI/before}(1,2,3)\UseHook {cmd/fooI/after}.
<argument> \fooI 
l. ...\test\newcommand*\fooI{(1,2,3)}
-> Adding cmd hook to 'fooJ' (before):
[lthooks] analyzing '\fooJ'
[lthooks] \fooJ=\long macro:->(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooJ/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooJ' (after):
[lthooks] analyzing '\fooJ'
[lthooks] \fooJ=\long macro:->\UseHook {cmd/fooJ/before}(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooJ/after (lbl) on input line ... <- after
> \fooJ=\long macro:
->\UseHook {cmd/fooJ/before}(1,2,3)\UseHook {cmd/fooJ/after}.
<argument> \fooJ 
l. ...\test\newcommand\fooJ{(1,2,3)}
-> Adding cmd hook to 'fooK' (before):
[lthooks] analyzing '\fooK'
[lthooks] \fooK=macro:->\protect \fooK  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooK/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooK' (after):
[lthooks] analyzing '\fooK'
[lthooks] \fooK=macro:->\protect \fooK  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooK/after (lbl) on input line ... <- after
> \fooK=robust macro:
->\protect \fooK  .
> \fooK =macro:
->\UseHook {cmd/fooK/before}(1,2,3)\UseHook {cmd/fooK/after}.
<argument> \fooK  
l. ...\test\DeclareRobustCommand*\fooK{(1,2,3)}
-> Adding cmd hook to 'fooL' (before):
[lthooks] analyzing '\fooL'
[lthooks] \fooL=macro:->\protect \fooL  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooL/before (lbl) on input line ... <- before
-> Adding cmd hook to 'fooL' (after):
[lthooks] analyzing '\fooL'
[lthooks] \fooL=macro:->\protect \fooL  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
**** Add to hook cmd/fooL/after (lbl) on input line ... <- after
> \fooL=robust macro:
->\protect \fooL  .
> \fooL =\long macro:
->\UseHook {cmd/fooL/before}(1,2,3)\UseHook {cmd/fooL/after}.
<argument> \fooL  
l. ...\test\DeclareRobustCommand\fooL{(1,2,3)}
