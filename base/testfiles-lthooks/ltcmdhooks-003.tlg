This is a generated file for the l3build validation system.
Don't change this file in any respect.
-> Adding cmd hook to 'fooA' (before):
[lthooks] analyzing '\fooA'
[lthooks] \fooA=\long macro:#1#2#3->(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Add to hook 'cmd/fooA/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooA' (after):
[lthooks] analyzing '\fooA'
[lthooks] \fooA=\long macro:#1#2#3->\UseHookWithArguments {cmd/fooA/before}{3}{#1}{#2}{#3}(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Add to hook 'cmd/fooA/after' (lbl) on input line ...
[lthooks]    <- after
> \fooA=\long macro:
#1#2#3->\UseHookWithArguments {cmd/fooA/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooA/after}{3}{#1}{#2}{#3}.
<argument> \fooA 
l. ...\test\newcommand\fooA[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooB' (before):
[lthooks] analyzing '\fooB'
[lthooks] \fooB=macro:->\@protected@testopt \fooB \\fooB {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooB/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooB' (after):
[lthooks] analyzing '\fooB'
[lthooks] \fooB=macro:->\@protected@testopt \fooB \\fooB {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooB/after' (lbl) on input line ...
[lthooks]    <- after
> \fooB=robust macro:
->\@protected@testopt \fooB \\fooB {x}.
> \\fooB=\long macro:
> default #1=x.
[#1]#2#3->\UseHookWithArguments {cmd/fooB/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooB/after}{3}{#1}{#2}{#3}.
<recently read> }
l. ...\test\newcommand\fooB[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooC' (before):
[lthooks] analyzing '\fooC'
[lthooks] \fooC=macro:->\protect \fooC  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooC/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooC' (after):
[lthooks] analyzing '\fooC'
[lthooks] \fooC=macro:->\protect \fooC  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooC/after' (lbl) on input line ...
[lthooks]    <- after
> \fooC=robust macro:
->\protect \fooC  .
> \fooC =\long macro:
#1#2#3->\UseHookWithArguments {cmd/fooC/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooC/after}{3}{#1}{#2}{#3}.
<argument> \fooC  
l. ......t\DeclareRobustCommand\fooC[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooD' (before):
[lthooks] analyzing '\fooD'
[lthooks] \fooD=macro:->\protect \fooD  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooD/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooD' (after):
[lthooks] analyzing '\fooD'
[lthooks] \fooD=macro:->\protect \fooD  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooD/after' (lbl) on input line ...
[lthooks]    <- after
> \fooD=robust macro:
->\protect \fooD  .
> \fooD =robust macro:
->\@protected@testopt \fooD  \\fooD  {x}.
> \\fooD =\long macro:
> default #1=x.
[#1]#2#3->\UseHookWithArguments {cmd/fooD/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooD/after}{3}{#1}{#2}{#3}.
<recently read> }
l. ......eclareRobustCommand\fooD[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooE' (before):
[lthooks] analyzing '\fooE'
[lthooks] \fooE=macro:#1#2#3->(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Add to hook 'cmd/fooE/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooE' (after):
[lthooks] analyzing '\fooE'
[lthooks] \fooE=macro:#1#2#3->\UseHookWithArguments {cmd/fooE/before}{3}{#1}{#2}{#3}(#1,#2,#3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] .. command can only be patched by rescanning
[lthooks] ++ trying to patch by retokenization
[lthooks] ++ macro can be retokenized cleanly
[lthooks] == retokenizing macro now
[lthooks] Add to hook 'cmd/fooE/after' (lbl) on input line ...
[lthooks]    <- after
> \fooE=macro:
#1#2#3->\UseHookWithArguments {cmd/fooE/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooE/after}{3}{#1}{#2}{#3}.
<argument> \fooE 
l. ...\test\newcommand*\fooE[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooF' (before):
[lthooks] analyzing '\fooF'
[lthooks] \fooF=macro:->\@protected@testopt \fooF \\fooF {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooF/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooF' (after):
[lthooks] analyzing '\fooF'
[lthooks] \fooF=macro:->\@protected@testopt \fooF \\fooF {x}
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooF/after' (lbl) on input line ...
[lthooks]    <- after
> \fooF=robust macro:
->\@protected@testopt \fooF \\fooF {x}.
> \\fooF=macro:
> default #1=x.
[#1]#2#3->\UseHookWithArguments {cmd/fooF/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooF/after}{3}{#1}{#2}{#3}.
<recently read> }
l. ...\test\newcommand*\fooF[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooG' (before):
[lthooks] analyzing '\fooG'
[lthooks] \fooG=macro:->\protect \fooG  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooG/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooG' (after):
[lthooks] analyzing '\fooG'
[lthooks] \fooG=macro:->\protect \fooG  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooG/after' (lbl) on input line ...
[lthooks]    <- after
> \fooG=robust macro:
->\protect \fooG  .
> \fooG =macro:
#1#2#3->\UseHookWithArguments {cmd/fooG/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooG/after}{3}{#1}{#2}{#3}.
<argument> \fooG  
l. ......\DeclareRobustCommand*\fooG[3]{(#1,#2,#3)}
-> Adding cmd hook to 'fooH' (before):
[lthooks] analyzing '\fooH'
[lthooks] \fooH=macro:->\protect \fooH  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooH/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooH' (after):
[lthooks] analyzing '\fooH'
[lthooks] \fooH=macro:->\protect \fooH  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooH/after' (lbl) on input line ...
[lthooks]    <- after
> \fooH=robust macro:
->\protect \fooH  .
> \fooH =robust macro:
->\@protected@testopt \fooH  \\fooH  {x}.
> \\fooH =macro:
> default #1=x.
[#1]#2#3->\UseHookWithArguments {cmd/fooH/before}{3}{#1}{#2}{#3}(#1,#2,#3)\UseHookWithArguments {cmd/fooH/after}{3}{#1}{#2}{#3}.
<recently read> }
l. ......clareRobustCommand*\fooH[3][x]{(#1,#2,#3)}
-> Adding cmd hook to 'fooI' (before):
[lthooks] analyzing '\fooI'
[lthooks] \fooI=macro:->(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooI/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooI' (after):
[lthooks] analyzing '\fooI'
[lthooks] \fooI=macro:->\UseHookWithArguments {cmd/fooI/before}{0}(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooI/after' (lbl) on input line ...
[lthooks]    <- after
> \fooI=macro:
->\UseHookWithArguments {cmd/fooI/before}{0}(1,2,3)\UseHookWithArguments {cmd/fooI/after}{0}.
<argument> \fooI 
l. ...\test\newcommand*\fooI{(1,2,3)}
-> Adding cmd hook to 'fooJ' (before):
[lthooks] analyzing '\fooJ'
[lthooks] \fooJ=macro:->(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooJ/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooJ' (after):
[lthooks] analyzing '\fooJ'
[lthooks] \fooJ=macro:->\UseHookWithArguments {cmd/fooJ/before}{0}(1,2,3)
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooJ/after' (lbl) on input line ...
[lthooks]    <- after
> \fooJ=macro:
->\UseHookWithArguments {cmd/fooJ/before}{0}(1,2,3)\UseHookWithArguments {cmd/fooJ/after}{0}.
<argument> \fooJ 
l. ...\test\newcommand\fooJ{(1,2,3)}
-> Adding cmd hook to 'fooK' (before):
[lthooks] analyzing '\fooK'
[lthooks] \fooK=macro:->\protect \fooK  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooK/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooK' (after):
[lthooks] analyzing '\fooK'
[lthooks] \fooK=macro:->\protect \fooK  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooK/after' (lbl) on input line ...
[lthooks]    <- after
> \fooK=robust macro:
->\protect \fooK  .
> \fooK =macro:
->\UseHookWithArguments {cmd/fooK/before}{0}(1,2,3)\UseHookWithArguments {cmd/fooK/after}{0}.
<argument> \fooK  
l. ...\test\DeclareRobustCommand*\fooK{(1,2,3)}
-> Adding cmd hook to 'fooL' (before):
[lthooks] analyzing '\fooL'
[lthooks] \fooL=macro:->\protect \fooL  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooL/before' (lbl) on input line ...
[lthooks]    <- before
-> Adding cmd hook to 'fooL' (after):
[lthooks] analyzing '\fooL'
[lthooks] \fooL=macro:->\protect \fooL  
[lthooks] ++ control sequence is defined
[lthooks] ++ control sequence is a macro
[lthooks] ++ macro is not private
[lthooks] ++ command can be patched without rescanning
[lthooks] Add to hook 'cmd/fooL/after' (lbl) on input line ...
[lthooks]    <- after
> \fooL=robust macro:
->\protect \fooL  .
> \fooL =macro:
->\UseHookWithArguments {cmd/fooL/before}{0}(1,2,3)\UseHookWithArguments {cmd/fooL/after}{0}.
<argument> \fooL  
l. ...\test\DeclareRobustCommand\fooL{(1,2,3)}
